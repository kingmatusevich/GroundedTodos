{"version":3,"sources":["ground:minimax/ejson.minimax.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,E;;;AAGA,4C;AACA,sD;AACA,sD;AACA,oD;AACA,oD;;AAEA,mF;;AAEA,0B;;AAEA,yB;;AAEA,6B;;AAEA,yB;;AAEA,sB;AACA,kB;AACA,a;AACA,c;AACA,iB;AACA,c;AACA,a;AACA,I;;AAEA,kE;;AAEA,4C;;AAEA,mB;;AAEA,yB;AACA,wC;AACA,0E;AACA,S;AACA,M;;AAEA,4B;AACA,+B;AACA,oB;;AAEA,sC;AACA,mC;AACA,kC;;AAEA,+B;AACA,4B;;AAEA,wE;AACA,kC;AACA,qE;;AAEA,iC;AACA,0D;AACA,yG;AACA,I;;AAEA,8D;AACA,oB;AACA,sB;;AAEA,uB;AACA,+C;;AAEA,yC;AACA,0B;AACA,gD;AACA,mC;AACA,uE;AACA,qE;AACA,2B;AACA,6C;AACA,oC;AACA,8C;AACA,4B;AACA,kB;AACA,W;AACA,S;AACA,sB;AACA,+B;AACA,8C;AACA,kE;AACA,qE;AACA,uB;AACA,kF;AACA,qE;AACA,gD;AACA,6C;AACA,mC;AACA,W;AACA,S;AACA,qC;AACA,gC;AACA,gB;AACA,S;AACA,O;AACA,iD;AACA,8B;AACA,+C;AACA,O;AACA,sB;AACA,M;;AAEA,yC;AACA,uC;AACA,sB;AACA,sB;;AAEA,2C;;AAEA,yD;AACA,iB;;AAEA,mD;;AAEA,0D;AACA,6C;AACA,4B;AACA,wB;AACA,gC;AACA,W;;AAEA,8B;AACA,2C;;AAEA,gB;AACA,4D;AACA,gD;AACA,wD;AACA,iF;;AAEA,8C;AACA,8C;AACA,gC;AACA,+B;AACA,kB;;AAEA,iC;AACA,2B;AACA,iC;AACA,oB;AACA,qE;AACA,mC;AACA,a;AACA,W;AACA,S;AACA,S;;AAEA,oB;AACA,yC;AACA,iC;AACA,c;AACA,8D;AACA,O;;;AAGA,oB;AACA,M;;AAEA,gD;AACA,qC;AACA,oB;AACA,K;;AAEA,oC;;AAEA,oD;AACA,I;;;AAGA,gD;AACA,+C;AACA,oB;;AAEA,8B;AACA,iD;AACA,sB;AACA,oB;AACA,K;;AAEA,mB;AACA,+C;AACA,4B;;AAEA,4B;AACA,yB;;AAEA,yC;AACA,mD;AACA,oC;AACA,yD;;AAEA,0E;AACA,+C;AACA,6C;AACA,4B;AACA,0B;AACA,iD;AACA,qC;AACA,iD;AACA,kB;AACA,mC;AACA,W;AACA,S;AACA,c;AACA,wB;AACA,iD;AACA,+D;AACA,gC;AACA,2B;AACA,gD;AACA,8C;AACA,qC;AACA,kD;AACA,kB;AACA,sD;AACA,qE;AACA,4B;AACA,wC;AACA,a;AACA,gC;AACA,W;AACA,S;AACA,O;AACA,oB;AACA,M;;AAEA,8B;AACA,I;;AAEA,uD;AACA,0B;AACA,wD;AACA,6B;AACA,2C;AACA,I;;AAEA,mD;AACA,8C;AACA,kD;AACA,wB;AACA,uC;AACA,I;;AAEA,gF;AACA,qB;AACA,gF;;AAEA,mC;;AAEA,kD;AACA,sD;AACA,E;;AAEA,mC;AACA,uC;AACA,E;;AAEA,mC;AACA,uC;AACA,E;;AAEA,+B;AACA,mC;AACA,E","file":"/packages/ground_minimax.js","sourcesContent":["/*\n\n\n                    __  ____       _ __  ___\n                   /  |/  (_)___  (_)  |/  /___ __  __\n                  / /|_/ / / __ \\/ / /|_/ / __ `/ |/_/\n                 / /  / / / / / / / /  / / /_/ />  <\n                /_/  /_/_/_/ /_/_/_/  /_/\\__,_/_/|_|\n\n  Minify and Maxify by RaiX aka Morten N.O. NÃ¸rgaard Henriksen (mh@gi-software.com)\n\n  MiniMax.minify( Object )\n\n  MiniMax.maxify( array )\n\n  MiniMax.stringify( object )\n\n  MiniMax.parse( string )\n\n  // For faster lookup\n  var keywords = {\n    '_id': 0,\n    'test': 1,\n    'comment': 2,\n    'list': 3,\n    'note': 4\n  };\n\n  var keywordsList = [ '_id', 'test', 'comment', 'list', 'note' ];\n\n  var headers = [0, [0, 1, 2], [0, 3, -5] ];\n\n  var data = []; */\n\n  // if(!Array.isArray) {\n  //   Array.isArray = function (vArg) {\n  //     return Object.prototype.toString.call(vArg) === '[object Array]';\n  //   };\n  // }\n\n  // Create the export scope\n  MiniMax = function(options) {\n    var self = this;\n\n    // Make sure we are on an instance\n    if (!(self instanceof MiniMax))\n      return new MiniMax(options);\n\n    // Make sure options is set\n    options = options || {};\n\n    // Setting this true will add all values and dates to the dictionary\n    // This can in some cases save\n    self.progressive = (options.progressive === false)? false : true;\n\n    // Set the default Dictionary\n    // If the user added initial dictionary then add those\n    self.dictionary = new Dictionary(_.union([false, true, null, undefined], options.dictionary || [] ));\n  };\n\n  MiniMax.prototype.minify = function(maxObj, skipFunctions) {\n    var self = this;\n    var headers = [0];\n\n    // Start dictionary\n    var dict = new Dictionary(self.dictionary);\n\n    var getHeader = function(newHeader) {\n      var headerId = null;\n      for (var i = 1; i < headers.length; i++) {\n        var orgHeader = headers[i];\n        // We only need to iterate over the intersection to get a match\n        var minLength = Math.min(orgHeader.length, newHeader.length);\n        var isMatch = true;\n        for (var a = 0; a < minLength; a++) {\n          // We break if not a match\n          if (orgHeader[a] !== newHeader[a]) {\n            isMatch = false;\n            break;\n          }\n        }\n        if (isMatch) {\n          // We check to see if\n          // We are equal or in another header\n          // eg. headers = [1, 2, 3] newHeader=[1, 2, 3] return id\n          // eg. headers = [1, 2, 3, 4] newHeader=[1, 2, 3] return id\n          headerId = i;\n          // We could maybe contain another header - so we extend the org. and use\n          // that eg. headers = [1, 2, 3] newHeader=[1, 2, 3, 4] then\n          // set headers=newHeader and return id\n          if (newHeader.length > minLength) {\n            headers[i] = newHeader;\n          }\n        }\n        // Stop when we found a match\n        if (headerId !== null) {\n          break;\n        }\n      }\n      // Or none of the above we add a new header\n      if (headerId === null) {\n        headerId = headers.push(newHeader) - 1;\n      }\n      return headerId;\n    };\n\n    var minifyHelper = function(maxObj) {\n      var inArray = !_.isArray(maxObj);\n      var target = [];\n      var header = [];\n\n      _.each(maxObj, function(value, key) {\n\n        if (skipFunctions && typeof value === 'function')\n          return;\n\n        var minKey = (inArray) ? dict.add(key) : 0;\n\n        if (value !== null && typeof value === 'object' &&\n                  !(value instanceof Date)) {\n          // Array or Object\n          if (inArray) {\n            header.push(minKey);\n          }\n\n          // Handle the object\n          target.push(minifyHelper(value));\n\n        } else {\n          // Depending on the progressive settings this will\n          // Check if value is found in keywords\n          // Always set the value in keywords dictionary\n          var valueId = (self.progressive) ? dict.add(value) : dict.index(value);\n\n          if (typeof valueId == 'undefined') {\n            // Not found, we add normal values\n            header.push(minKey);\n            target.push(value);\n          } else {\n\n            header.push(-minKey);\n            if (!inArray) {\n              target.push(value);\n            } else {\n              // Found, make minKey negative and set value to valueId\n              target.push(valueId);\n            }\n          }\n        }\n      });\n\n      if (inArray) {\n        var headerId = getHeader(header);\n        target.unshift(headerId);\n      } else {\n        target.unshift(0); // 0 marks an array with no headers\n      }\n\n\n      return target;\n    };\n\n    // If not an object then not much to work on\n    if (typeof maxObj !== 'object') {\n      return maxObj;\n    }\n\n    var data = minifyHelper(maxObj);\n\n    return [ dict.withoutInitial(), headers, data ];\n  };\n\n\n  // Takes an minify object and maxify to object\n  MiniMax.prototype.maxify = function(minObj) {\n    var self = this;\n\n    // We expect an array of 3\n    if (minObj === null || minObj.length !== 3) {\n      // Return object\n      return minObj;\n    }\n\n    // Init globals\n    var dict = new Dictionary(self.dictionary);\n    dict.addList(minObj[0]);\n\n    var headers = minObj[1];\n    var data = minObj[2];\n\n    var maxifyHelper = function(minObj) {\n      // read header reference and fetch the header\n      var headerId = minObj.shift();\n      var header = (headerId) ? headers[headerId] : null;\n\n      // If header === 0 then we are creating an array otherwise an object\n      var result = (header === null) ? [] : {};\n      // We launch interation over the minObj\n      if (header === null) {\n        // Create an array\n        for (var i = 0; i < minObj.length; i++) {\n          if (_.isArray(minObj[i])) {\n            result.push(maxifyHelper(minObj[i]));\n          } else {\n            result.push(minObj[i]);\n          }\n        }\n      } else {\n        // Create object\n        for (var i = 0; i < minObj.length; i++) {\n          // Lookup keyword id can be negative for value lookup\n          var keyId = header[i];\n          // Lookup keyword\n          var key = dict.value(Math.abs(keyId));\n          // Is value an array then dig deeper\n          if (_.isArray(minObj[i])) {\n            result[key] = maxifyHelper(minObj[i]);\n          } else {\n            var value = minObj[i]; // Value or valueId\n            // if keyId is negative then lookup the value in keywords\n            if (keyId < 0) {\n              value = dict.value(value);\n            }\n            result[key] = value;\n          }\n        }\n      }\n      return result;\n    };\n\n    return maxifyHelper(data);\n  };\n\n  MiniMax.prototype.stringify = function(plainObject) {\n    // Compress the object\n    var minifiedObject = this.minify(plainObject, true);\n    // Convert it into string\n    return EJSON.stringify(minifiedObject);\n  };\n\n  MiniMax.prototype.parse = function(ejsonString) {\n    // Convert the string into minified object\n    var minifiedObject = EJSON.parse(ejsonString);\n    // Maxify the object\n    return this.maxify(minifiedObject);\n  };\n\n////////////////////////////////////////////////////////////////////////////////\n//  DEFAULT BEHAVIOUR\n////////////////////////////////////////////////////////////////////////////////\n\nvar defaultMiniMax = new MiniMax();\n\nMiniMax.minify = function(maxObj, skipFunctions) {\n  return defaultMiniMax.minify(maxObj, skipFunctions);\n};\n\nMiniMax.maxify = function(minObj) {\n  return defaultMiniMax.maxify(minObj);\n};\n\nMiniMax.stringify = function(obj) {\n  return defaultMiniMax.stringify(obj);\n};\n\nMiniMax.parse = function(str) {\n  return defaultMiniMax.parse(str);\n};\n"]}